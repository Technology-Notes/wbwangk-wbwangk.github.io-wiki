Observation 11: With CouchDB, the endorsement latency
and ledger update latency increased with an increase in the
number of writes per transaction, i.e., from 40 ms and 240
ms with one write to 800 ms and 1200 ms with three writes,
respectively, as shown in Figure 12(b) even though write-only
transactions do not access the database during the endorsement
phase. This is because the endorsement phase acquired a
shared read lock on the whole database to provide a consistent
view of data (i.e., repeatable read isolation level [17]) to the
chaincode. Similarly, the final ledger update phase acquired an
exclusive write lock on the whole database. Hence, both the
endorsement phase and final ledger update contended for this
resource. Especially, the final ledger update with CouchDB
was costlier as it had to perform the following three tasks for
each key-value write in a transaction’s write-set.
1) Retrieve the key’s previous revision number (used for
concurrency control within CouchDB) by issuing a GET
request, if it exists in the database.
2) Construct a document for the value (could be a JSON
document or binary attachment).
3) Update the database by submitting a PUT request.
As a result, with the increase in the number of writes per
transaction, the ledger update latency increased (refer to Figure

12(b)). Due to the above three time consuming serial oper-
ations, we surmise that the committer held the lock on the

database for a longer duration which increased endorsement
latency. To validate our hypothesis, we performed experiments
by disabling the lock acquisition on the whole database
during the endorsement phase and final ledger update. The
side effect of such action was only providing non-repeatable
read isolation level at that chaincode. As our transaction
was only writing keys, such side effect did not affect the
database consistency. Figure 12(d) shows the improvement in
endorsement phase. The average endorsement latency reduced
from 800 ms to 40 ms, validating our hypothesis.
Observation 12: Only with an increase in the number of
reads per transaction, the MVCC latency increased as shown
in Figure 12(c). This is because with an increase in the number

of items in the read set, the number of GET REST API calls
to CouchDB increased during MVCC validation phase. With
an increase in the number of writes, MVCC latency did not
increase as shown in Figure 12(b) because it only checks
whether any read keys has been modified.
Guideline 6: GoLevelDB is a better performant option
for state database. CouchDB is a better choice if rich-query
support for read-only transactions is important. When using
CouchDB, design the application and transaction to read/write
a fewer number of keys to accomplish a task.

Action Item 4: CouchDB supports bulk read/write oper-
ations [3] without additional transactional semantics. Using

the bulk operations will reduce the lock holding duration and
improve the performance as demonstrated in §VI-C.
Action Item 5: The usage of database such as GoLevelDB
and CouchDB, without the snapshot isolation level, results in
whole database lock during the endorsement and the ledger
update phase. Hence, our future work [11] is to look at ways
to remove the lock and/or use a database such as PostgreSQL
[12] that supports snapshot isolation.