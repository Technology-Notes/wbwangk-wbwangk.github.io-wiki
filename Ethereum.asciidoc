## 发行自己的以太坊ERC20 Token
[原文](http://blog.csdn.net/sinat_34070003/article/details/79107181)  

### 安装以太坊轻钱包MetaMask
[MetaMask](https://link.jianshu.com/?t=https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn?authuser=2)是一款在谷歌浏览器Chrome上使用的插件类型的以太坊钱包，该钱包不需要下载，只需要在谷歌浏览器添加对应的扩展程序即可，非常轻量级，使用起来也非常方便。（可能需要翻墙才能安装）[1](http://8btc.com/thread-76137-1-5.html)   

安装好MetaMask后Chrome右上角会多了一个橙色的狐狸头图标。点图标会打开MetaMask浮动框。新建钱包，输入密码。

MetaMask会为用户创建12个英文助记词，一定要保存好这些助记词，一定要保存好这些助记词，一定要保存好这些助记词。在其他钱包导入这个新创建的账户的时候需要输入这些助记词。

在以太坊的主网络上发布智能合约需要以太币(ETH)，而使用测试网络可以直接申请到测试用的以太币。在MetaMask浮动框的左上角的下拉框中选择`Ropsten Test Network`选项，来切换到测试网。这个测试网貌似由`infura.io`提供。

点击“BUY”按钮，然后点“ROPSTEN TEST FAUCET”。点击绿色的按钮“request 1 ether from faucet”，就可以领取1ETH。测试的话一个以太币够用了，如果再想多领点，就点[这个网址](https://link.jianshu.com/?t=http://faucet.ropsten.be:3001/%20)再领3个以太币(ETH)。倒是可以熟悉一下以太币地址的概念。

MetaMask浮动框上账户的地址显示不全，可以点账户傍边的三个黑点调出一个下拉框选择将账户地址复制到剪切板。如果我刚新建的账户地址是：
```
0x313117B29B6980603525e2de87145315879c17Eb
```
所有的加密货币都会有类似的地址，这代表了用户的账户，账户往往并余额。比特币的地址是用户公钥的哈希，以太币应该也差不多。

如果两个途径都领了，则你有了4个ETH，这可以在MetaMask中看到，最新版的MetaMask甚至显示这4个ETH价值多少美元。我这里显示的是价值2951.74美元，当然是这时的真正的以太币的价值。

做到这里你已经在Ropsten以太坊测试网络中拥有了4个以太币，可以部署自己的智能合约了。如果你拥有真正的以太币，当然也可以在以太坊的主网络上做测试，那么就是可以跳过这一节。

### 开发智能合约

以太坊的智能合约使用Solidity语言开发，这个语言（相对于比特币的脚本）是图灵完备的。为了让本测试简单，使用在线的开发工具。原文使用的是[Remix](https://link.jianshu.com/?t=https://ethereum.github.io/browser-solidity)，然我这里打开后只是一个白网页。从github的`https://github.com/ethereum/browser-solidity`项目上查到了Remix的另一个部署[https://remix.ethereum.org](https://remix.ethereum.org/)，用这个来调试智能合约源码。

一个代币智能合约的例子中[这个网址](https://link.jianshu.com/?t=https://ropsten.etherscan.io/address/0x655275d5ea52c62531aa43a85949c63dd858e0e0#code)可以看到，复制到Remix的左侧源码区即可。

**Run**选项卡中的**Environment**设置为`Injected Web3`，Create按钮左边的输入框中输入：
```
100000000,"zhongxh's test token",8,"ZTT"
```
含义是Token的数量、Token的全称、Token的精度(即Token最小为小数点后几位)、Token的符号。这个内容后面会用到，如果改变了需要记下来。

需要注意**Settings**选项卡中的Solidity版本，是在下拉框中选择的。我选择的版本是：
```
0.4.20-nightly.2018.1.29+commit.a668b9de
```
这个版本变化很快，需要记住你自己选择的版本。在后面在以太坊浏览器中进行合约校验时需要选择同样的Solidity版本，否则校验会失败。

点击Create按钮后，MetaMask会弹出的“CONFIRM TRANSACTION”的页面，这个页面是用来确认发送的，点击**SUBMIT**提交，再点**SENT**。

这时，创建智能合约的提案已经提交到了以太坊测试网Ropsten(infura.io)。在MetaMask的SENT选项卡中可以看到刚刚提交的智能合约提案，点击这个提案就跳转到了以太坊浏览器[etherscan](https://ropsten.etherscan.io/tx/0x5901912c0f23302a813c4462c3c1fee6724c767654dbb51cf9e2677ca1d1e8d3)我刚刚创建的交易中。智能合约的提案也是一种特殊的交易，也会被打包到区块中。

该交易的关键信息有：
```
From: 0x313117b29b6980603525e2de87145315879c17eb
To:[Contract 0x4292f38c4e1f13cf6f7a37a194e1616b365d5247 Created]  
Nonce: 1
```
From是我的钱包地址，To是智能合约的地址(Contract Address)。下面会用到智能合约地址。

这里的Nonce是当前账户发出的交易序号。我这里显示1是因为这是当前账户的第2个交易（貌似以太坊的合约地址是账户地址加上这个Nonce后哈希得到的）。

### 发布智能合约
在etherscan浏览器的**MISC**下拉菜单中选择**Verify Contract**，进入了合约校验页面。对于智能合约来说，需要校验的内容一是源码，二是初始化参数（构造函数参数）。因为源码决定了代币(Token)的运行逻辑，而初始化参数代表了初始状态（如代币总数）。

在etherscan中校验的合约不支持导入(import)，即仅支持把合约代码写在同一个程序文件中。

在输入框中输入的内容：
```
Contract address: 0x4292f38c4e1f13cf6f7a37a194e1616b365d5247
Contract name: HumanStandardToken
Compiler: 0.4.20-nightly.2018.1.29+commit.a668b9de
Optimization: No
```
上述信息可以在etherscan浏览器的[这个页面](https://ropsten.etherscan.io/address/0x4292f38c4e1f13cf6f7a37a194e1616b365d5247#code)查询到。
上述页面中还有合约源码和初始化参数。其中，初始化参数（Constructor Arguments (ABI-encoded and is the last bytes of the Contract Creation Code above)）如下：
```
0000000000000000000000000000000000000000000000000000000005f5e1000000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000147a686f6e6778682773207465737420746f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000035a54540000000000000000000000000000000000000000000000000000000000
```
上面的字符串是`100000000,"zhongxh's test token",8,"ZTT"`的ABI编码。

在合约校验页面上需要分别将合约源码和初始化参数分别粘贴好，然后点**Verify And Publish**按钮。

如果一切正常会显示校验通过。

### 测试智能合约
因为Metamask不支持toekn的发送，需要切换到[MyEtherWallet](https://link.jianshu.com/?t=https://www.myetherwallet.com/)钱包。

在**MyEtherWallet**页面上，点击右上角的下拉框来切换网络到`Ropsten(infura.io)`。把语言选择为简体中文。然后点超链接**发送以太币/发送代币**。用私钥的方式导入钱包。

点击Metamask右上角的“...”，然后点击"Export Private Key "，输入密码，即可获得私钥。将私钥拷到MyEtherWallet，就可以解锁你的钱包了。

钱包解锁后在屏幕右侧显示：
```
账户地址：
0x313117B29B6980603525e2de87145315879c17Eb
账户余额：
3.986141362 ROPSTEN ETH
```
这只是你账户上的以太币余额，而不是你要发行的ZTT代币的余额。

点击右下角的**Add Custom Token**按钮，调出三个输入框，输入：
```
地址 Token Contract: 0x4292f38c4e1f13cf6f7a37a194e1616b365d5247
代币符号: ZTT
小数点位数: 8
```
点击**保存**按钮，然后就出现了ZTT的余额的显示：
```
1 ZTT
```
#### MetaMask显示代币
在MetaMask浮动框中选择**Tokens**选项卡，点击**ADD TOKEN**按钮，输入合约地址：
```
0x4292f38c4e1f13cf6f7a37a194e1616b365d5247
```
MetaMask自动填充剩余输入框，然后显示余额：
```
You own 1 token
1.000 ZTT
```

### 测试代币
下面测试一下代币在多个账户之间的转移。  

在MetaMask中新建一个账号。方法是点击MetaMask浮动框右上角的头像图标，点选**Create Account**，就创建了`Acccount 2`。新账户的地址：
```
0xaD32794E0681ab84972F74D799bF683aA87a45c6
```
Account2的余额是：0ETH、0ZTT。  

象上文一样向faucet讨要1个ETH。会启动一个交易，然后在MetaMask中看到Account2拥有了1ETH。

#### Account2向Account1转账ETH
MetaMask的当前账户是Account2，点**SEND**按钮，在交易的目标地址中粘贴入Account1的地址：
```
0x313117B29B6980603525e2de87145315879c17Eb
```
数量上输入0.5，然后点**NEXT**按钮，再点**SUBMIT**就提交了转账交易。在**SENT**选项卡中可以看到新建的交易。点击该交易会跳到Etherscan浏览器，浏览器会显示这个交易的详细信息。

交易被确认后（以太坊的确认周期是15秒左右），MetaMask中可以看到账户中ETH余额的变化。

#### 代币的转账
仍通过 [https://www.myetherwallet.com](https://www.myetherwallet.com) 来完成代币ZTT的转账。

1. 通过MetaMask切换账户到Account1，导出Account1的私钥。

2. 进入myetherwallet.com，通过“发送以太币/发送代币”菜单导入私钥(解锁)。

3. 在“发送至地址”中输入Account1的地址`0x313117B29B6980603525e2de87145315879c17Eb`，转账金额是0.1，下拉框中选择ZTT，点“生成交易”按钮

4. 会有提示，意思是得等以太坊的矿工生成区块才算转账成功。可以按提示去看交易状态。

5. 成功后在MetaMask中切换账户到Account2，可以看到Account2的ZTT代币的余额现在是0.1ZTT了。

## 笔记
### 详解以太坊的工作原理
[1](https://baijiahao.baidu.com/s?id=1581231980661527205&wfr=spider&for=pc)
以太坊的哈希算法:KECCAK-256  

以太坊有两种类型的账户：

1. 外部拥有的账户，被私钥控制且没有任何代码与之关联

2. 合约账户，被它们的合约代码控制且有代码与之关联

![](https://t12.baidu.com/it/u=3959818670,2742092085&fm=173&s=B1B14D308322650B5B4D7C5A030050F0&w=640&h=298&img.JPEG)

### 以太坊黄皮书
[地址](https://github.com/yuange1024/ethereum_yellowpaper/blob/master/Paper_Chinese.pdf)  

**账户状态**包含以下四个字段：

- nonce，随机数：这个值等于账户发出的交易数与这个账户创建的合约数量之和。（创建合约本来就是交易的一种，所以这个值就是该账户的交易数）

- balance，余额：表示这个账户拥有多少Wei。（1ETH=Wei*10^18）

- storageRoot，存储根节点：保存账户内容的Merkle Paricia树根节点的256位哈希编码到字典树中，作为从256位整数键值哈希的Keccak 256位哈希到256位整数的RLP-编码映射。

- codeHash，代码哈希：这个账户的ENM(Ethereum Virtual Machine，以太坊虚拟机)代码哈希值——代码执行时，这个地址会接受一个消息调用；它和其他字段不同，创建后不可更改。状态数据库中包含所有像这样的代码片段哈希，以便后续使用。

#### 交易的字段
- nonce，随机数：账户状态中nonce的当前值

- gasPrice，燃料价格：为执行交易所需要的计算资源付出的gas价格，以Wei为单位

- gasLimit，燃料上限：用于执行交易的最大gas数量。这个值须在交易前设置，且设置后不能再修改。（可以理解为油箱大小，如果路程远请换大油箱）

- to，接收者地址：消息调用接收者的160位地址。对于合约创建交易，无需接收者地址

- value，转账额度：转到接收者账户的额度，以Wei为单位。对于合约创建，表示捐助到合约地址的额度

- init，初始化（合约创建专用字段）：一个不限制大小的字节数组，表示账户初始化程序的EVM代码。init是EVM代码片段；执行init后会返回另外一个代码片段，每次合约接受小说调用（通过交易或内部调用）后都会执行这个代码片段。仅当合约账户创建时会执行一次init。

- data，数据（消息调用专用字段）：一个不限制大小的字节数据，表示消息调用的输入数据

#### 区块的字段
区块头字段：

- parentHash，父块哈希：父区块头的Keccak 256位哈希

- ommersHash，叔链哈希：当前区块的叔链列表Keccak 256位哈希

- beneficiary，受益者地址：成功挖到这个区块的160位地址，这个区块中的所有交易费都会转到这个地址

- stateRoot，状态字典树根节点哈希：状态字典树根节点的Keccak 256位哈希，交易打包到当前区块且区块定稿后可以生成这个值

- transactionsRoot，交易字典树根节点哈希：交易字典树根节点Keccak 256位哈希，在交易字典树含有区块中的所有交易列表

- receiptsRoot，接受者字典树根节点哈希：接受者字典树根节点的Keccak 256位哈希，在接受者字典树含有区块中的所有交易信息中的接收者。

（略）